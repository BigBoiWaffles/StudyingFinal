EXERCISE: Use Java or python3 to find the representations for the following
          7.1 and .03 in the IEEE754 single standard.
EXERCISE: Add the following IEEE754 numbers. Assume that the arithmetic
          is done double precision and then rounded back to single precision.

          0[10000010]11000110011001100110011
          0[01111010]11101011100001010001111

Number A:
Sign bit = 0
Exponent bit = 10000010 = 2 + 128 = 130 => 130 - 127 = 3 
Mantissa = 11000110011001100110011

Number B:
Sign bit = 0
exponent bit = 01111010 = 2 + 8 + 16 + 32 + 64 = 122 => 122 - 127 = -5
Mantissa = 11101011100001010001111

Now we shift the smaller exponent to the larger exponent
3 - (-5) = 3 + 5 = 8
Thus number B is 
original: 1.11101011100001010001111
shifted : 0.0000000111101011100001010001111

Now we add 
1.1100011001100110011001100000000 + 
0.0000000111101011100001010001111 (Remember 1 + 1 + 1 = 3 => binary(3) = 11, so we split it, 1 goes in the sum and 1 carries over)
---------------------------------
1.1100100001010001111010110001111 * 2^3 

Now we shift it back to single precision, we only look at the first 23 bits 

1.11001000010100011110101 (10001111)
Rounding 
Guard bit = 1
Sticky bit (Any non-zeros after guard?) - Yes 
thus we round up.

1.11001000010100011110101 +
                        1
-------------------------
1.11001000010100011110110

Thus we get the following 
Sign bit = 0
Exponent = 3 (we didnt normalize the result so 127 + 3 = 130 => 10000010)
Mantissa = 11001000010100011110110
